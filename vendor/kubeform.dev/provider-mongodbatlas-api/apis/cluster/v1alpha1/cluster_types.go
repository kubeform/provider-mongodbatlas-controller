/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Cluster struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec,omitempty"`
	Status            ClusterStatus `json:"status,omitempty"`
}

type ClusterSpecAdvancedConfiguration struct {
	// +optional
	FailIndexKeyTooLong *bool `json:"failIndexKeyTooLong,omitempty" tf:"fail_index_key_too_long"`
	// +optional
	JavascriptEnabled *bool `json:"javascriptEnabled,omitempty" tf:"javascript_enabled"`
	// +optional
	MinimumEnabledTlsProtocol *string `json:"minimumEnabledTlsProtocol,omitempty" tf:"minimum_enabled_tls_protocol"`
	// +optional
	NoTableScan *bool `json:"noTableScan,omitempty" tf:"no_table_scan"`
	// +optional
	OplogSizeMb *int64 `json:"oplogSizeMb,omitempty" tf:"oplog_size_mb"`
	// +optional
	SampleRefreshIntervalBiConnector *int64 `json:"sampleRefreshIntervalBiConnector,omitempty" tf:"sample_refresh_interval_bi_connector"`
	// +optional
	SampleSizeBiConnector *int64 `json:"sampleSizeBiConnector,omitempty" tf:"sample_size_bi_connector"`
}

type ClusterSpecBiConnectorConfig struct {
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// +optional
	ReadPreference *string `json:"readPreference,omitempty" tf:"read_preference"`
}

type ClusterSpecConnectionStringsPrivateEndpointEndpoints struct {
	// +optional
	EndpointID *string `json:"endpointID,omitempty" tf:"endpoint_id"`
	// +optional
	ProviderName *string `json:"providerName,omitempty" tf:"provider_name"`
	// +optional
	Region *string `json:"region,omitempty" tf:"region"`
}

type ClusterSpecConnectionStringsPrivateEndpoint struct {
	// +optional
	ConnectionString *string `json:"connectionString,omitempty" tf:"connection_string"`
	// +optional
	Endpoints []ClusterSpecConnectionStringsPrivateEndpointEndpoints `json:"endpoints,omitempty" tf:"endpoints"`
	// +optional
	SrvConnectionString *string `json:"srvConnectionString,omitempty" tf:"srv_connection_string"`
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
}

type ClusterSpecConnectionStrings struct {
	// +optional
	// Deprecated
	AwsPrivateLink map[string]string `json:"awsPrivateLink,omitempty" tf:"aws_private_link"`
	// +optional
	// Deprecated
	AwsPrivateLinkSrv map[string]string `json:"awsPrivateLinkSrv,omitempty" tf:"aws_private_link_srv"`
	// +optional
	Private *string `json:"private,omitempty" tf:"private"`
	// +optional
	PrivateEndpoint []ClusterSpecConnectionStringsPrivateEndpoint `json:"privateEndpoint,omitempty" tf:"private_endpoint"`
	// +optional
	PrivateSrv *string `json:"privateSrv,omitempty" tf:"private_srv"`
	// +optional
	Standard *string `json:"standard,omitempty" tf:"standard"`
	// +optional
	StandardSrv *string `json:"standardSrv,omitempty" tf:"standard_srv"`
}

type ClusterSpecLabels struct {
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ClusterSpecReplicationSpecsRegionsConfig struct {
	// +optional
	AnalyticsNodes *int64 `json:"analyticsNodes,omitempty" tf:"analytics_nodes"`
	// +optional
	ElectableNodes *int64 `json:"electableNodes,omitempty" tf:"electable_nodes"`
	// +optional
	Priority *int64 `json:"priority,omitempty" tf:"priority"`
	// +optional
	ReadOnlyNodes *int64  `json:"readOnlyNodes,omitempty" tf:"read_only_nodes"`
	RegionName    *string `json:"regionName" tf:"region_name"`
}

type ClusterSpecReplicationSpecs struct {
	// +optional
	ID        *string `json:"ID,omitempty" tf:"id"`
	NumShards *int64  `json:"numShards" tf:"num_shards"`
	// +optional
	RegionsConfig []ClusterSpecReplicationSpecsRegionsConfig `json:"regionsConfig,omitempty" tf:"regions_config"`
	// +optional
	ZoneName *string `json:"zoneName,omitempty" tf:"zone_name"`
}

type ClusterSpecSnapshotBackupPolicyPoliciesPolicyItem struct {
	// +optional
	FrequencyInterval *int64 `json:"frequencyInterval,omitempty" tf:"frequency_interval"`
	// +optional
	FrequencyType *string `json:"frequencyType,omitempty" tf:"frequency_type"`
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// +optional
	RetentionUnit *string `json:"retentionUnit,omitempty" tf:"retention_unit"`
	// +optional
	RetentionValue *int64 `json:"retentionValue,omitempty" tf:"retention_value"`
}

type ClusterSpecSnapshotBackupPolicyPolicies struct {
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// +optional
	PolicyItem []ClusterSpecSnapshotBackupPolicyPoliciesPolicyItem `json:"policyItem,omitempty" tf:"policy_item"`
}

type ClusterSpecSnapshotBackupPolicy struct {
	// +optional
	ClusterID *string `json:"clusterID,omitempty" tf:"cluster_id"`
	// +optional
	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name"`
	// +optional
	NextSnapshot *string `json:"nextSnapshot,omitempty" tf:"next_snapshot"`
	// +optional
	Policies []ClusterSpecSnapshotBackupPolicyPolicies `json:"policies,omitempty" tf:"policies"`
	// +optional
	ReferenceHourOfDay *int64 `json:"referenceHourOfDay,omitempty" tf:"reference_hour_of_day"`
	// +optional
	ReferenceMinuteOfHour *int64 `json:"referenceMinuteOfHour,omitempty" tf:"reference_minute_of_hour"`
	// +optional
	RestoreWindowDays *int64 `json:"restoreWindowDays,omitempty" tf:"restore_window_days"`
	// +optional
	UpdateSnapshots *bool `json:"updateSnapshots,omitempty" tf:"update_snapshots"`
}

type ClusterSpec struct {
	State *ClusterSpecResource `json:"state,omitempty" tf:"-"`

	Resource ClusterSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ClusterSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// +optional
	AdvancedConfiguration *ClusterSpecAdvancedConfiguration `json:"advancedConfiguration,omitempty" tf:"advanced_configuration"`
	// +optional
	AutoScalingComputeEnabled *bool `json:"autoScalingComputeEnabled,omitempty" tf:"auto_scaling_compute_enabled"`
	// +optional
	AutoScalingComputeScaleDownEnabled *bool `json:"autoScalingComputeScaleDownEnabled,omitempty" tf:"auto_scaling_compute_scale_down_enabled"`
	// +optional
	AutoScalingDiskGbEnabled *bool `json:"autoScalingDiskGbEnabled,omitempty" tf:"auto_scaling_disk_gb_enabled"`
	// +optional
	BackingProviderName *string `json:"backingProviderName,omitempty" tf:"backing_provider_name"`
	// +optional
	BackupEnabled *bool `json:"backupEnabled,omitempty" tf:"backup_enabled"`
	// +optional
	// Deprecated
	BiConnector *map[string]string `json:"biConnector,omitempty" tf:"bi_connector"`
	// +optional
	BiConnectorConfig *ClusterSpecBiConnectorConfig `json:"biConnectorConfig,omitempty" tf:"bi_connector_config"`
	// +optional
	ClusterID *string `json:"clusterID,omitempty" tf:"cluster_id"`
	// +optional
	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type"`
	// +optional
	ConnectionStrings []ClusterSpecConnectionStrings `json:"connectionStrings,omitempty" tf:"connection_strings"`
	// +optional
	ContainerID *string `json:"containerID,omitempty" tf:"container_id"`
	// +optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb"`
	// +optional
	EncryptionAtRestProvider *string `json:"encryptionAtRestProvider,omitempty" tf:"encryption_at_rest_provider"`
	// +optional
	Labels []ClusterSpecLabels `json:"labels,omitempty" tf:"labels"`
	// +optional
	MongoDbMajorVersion *string `json:"mongoDbMajorVersion,omitempty" tf:"mongo_db_major_version"`
	// +optional
	MongoDbVersion *string `json:"mongoDbVersion,omitempty" tf:"mongo_db_version"`
	// +optional
	MongoURI *string `json:"mongoURI,omitempty" tf:"mongo_uri"`
	// +optional
	MongoURIUpdated *string `json:"mongoURIUpdated,omitempty" tf:"mongo_uri_updated"`
	// +optional
	MongoURIWithOptions *string `json:"mongoURIWithOptions,omitempty" tf:"mongo_uri_with_options"`
	Name                *string `json:"name" tf:"name"`
	// +optional
	NumShards *int64 `json:"numShards,omitempty" tf:"num_shards"`
	// +optional
	Paused *bool `json:"paused,omitempty" tf:"paused"`
	// +optional
	PitEnabled *bool   `json:"pitEnabled,omitempty" tf:"pit_enabled"`
	ProjectID  *string `json:"projectID" tf:"project_id"`
	// +optional
	ProviderAutoScalingComputeMaxInstanceSize *string `json:"providerAutoScalingComputeMaxInstanceSize,omitempty" tf:"provider_auto_scaling_compute_max_instance_size"`
	// +optional
	ProviderAutoScalingComputeMinInstanceSize *string `json:"providerAutoScalingComputeMinInstanceSize,omitempty" tf:"provider_auto_scaling_compute_min_instance_size"`
	// +optional
	ProviderBackupEnabled *bool `json:"providerBackupEnabled,omitempty" tf:"provider_backup_enabled"`
	// +optional
	ProviderDiskIops *int64 `json:"providerDiskIops,omitempty" tf:"provider_disk_iops"`
	// +optional
	ProviderDiskTypeName *string `json:"providerDiskTypeName,omitempty" tf:"provider_disk_type_name"`
	// +optional
	// Deprecated
	ProviderEncryptEbsVolume *bool `json:"providerEncryptEbsVolume,omitempty" tf:"provider_encrypt_ebs_volume"`
	// +optional
	ProviderEncryptEbsVolumeFlag *bool   `json:"providerEncryptEbsVolumeFlag,omitempty" tf:"provider_encrypt_ebs_volume_flag"`
	ProviderInstanceSizeName     *string `json:"providerInstanceSizeName" tf:"provider_instance_size_name"`
	ProviderName                 *string `json:"providerName" tf:"provider_name"`
	// +optional
	ProviderRegionName *string `json:"providerRegionName,omitempty" tf:"provider_region_name"`
	// +optional
	ProviderVolumeType *string `json:"providerVolumeType,omitempty" tf:"provider_volume_type"`
	// +optional
	ReplicationFactor *int64 `json:"replicationFactor,omitempty" tf:"replication_factor"`
	// +optional
	ReplicationSpecs []ClusterSpecReplicationSpecs `json:"replicationSpecs,omitempty" tf:"replication_specs"`
	// +optional
	SnapshotBackupPolicy []ClusterSpecSnapshotBackupPolicy `json:"snapshotBackupPolicy,omitempty" tf:"snapshot_backup_policy"`
	// +optional
	SrvAddress *string `json:"srvAddress,omitempty" tf:"srv_address"`
	// +optional
	StateName *string `json:"stateName,omitempty" tf:"state_name"`
}

type ClusterStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ClusterList is a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Cluster CRD objects
	Items []Cluster `json:"items,omitempty"`
}
