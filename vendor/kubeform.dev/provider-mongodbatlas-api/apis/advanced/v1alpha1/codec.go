/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAdvancedConfiguration{}).Type1()):                       ClusterSpecAdvancedConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBiConnector{}).Type1()):                                 ClusterSpecBiConnectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}).Type1()): ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}).Type1()):    ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}).Type1()): ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}).Type1()):  ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAdvancedConfiguration{}).Type1()):                       ClusterSpecAdvancedConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBiConnector{}).Type1()):                                 ClusterSpecBiConnectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}).Type1()): ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}).Type1()):    ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}).Type1()): ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}).Type1()):  ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ClusterSpecAdvancedConfigurationCodec struct {
}

func (ClusterSpecAdvancedConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAdvancedConfiguration)(ptr) == nil
}

func (ClusterSpecAdvancedConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAdvancedConfiguration)(ptr)
	var objs []ClusterSpecAdvancedConfiguration
	if obj != nil {
		objs = []ClusterSpecAdvancedConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAdvancedConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAdvancedConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAdvancedConfiguration)(ptr) = ClusterSpecAdvancedConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAdvancedConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAdvancedConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAdvancedConfiguration)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAdvancedConfiguration)(ptr) = ClusterSpecAdvancedConfiguration{}
			}
		} else {
			*(*ClusterSpecAdvancedConfiguration)(ptr) = ClusterSpecAdvancedConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecAdvancedConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAdvancedConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecAdvancedConfiguration)(ptr) = obj
		} else {
			*(*ClusterSpecAdvancedConfiguration)(ptr) = ClusterSpecAdvancedConfiguration{}
		}
	default:
		iter.ReportError("decode ClusterSpecAdvancedConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecBiConnectorCodec struct {
}

func (ClusterSpecBiConnectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecBiConnector)(ptr) == nil
}

func (ClusterSpecBiConnectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecBiConnector)(ptr)
	var objs []ClusterSpecBiConnector
	if obj != nil {
		objs = []ClusterSpecBiConnector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBiConnector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecBiConnectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecBiConnector)(ptr) = ClusterSpecBiConnector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecBiConnector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBiConnector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecBiConnector)(ptr) = objs[0]
			} else {
				*(*ClusterSpecBiConnector)(ptr) = ClusterSpecBiConnector{}
			}
		} else {
			*(*ClusterSpecBiConnector)(ptr) = ClusterSpecBiConnector{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecBiConnector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBiConnector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecBiConnector)(ptr) = obj
		} else {
			*(*ClusterSpecBiConnector)(ptr) = ClusterSpecBiConnector{}
		}
	default:
		iter.ReportError("decode ClusterSpecBiConnector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec struct {
}

func (ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) == nil
}

func (ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr)
	var objs []ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs
	if obj != nil {
		objs = []ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}
			}
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = obj
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs{}
		}
	default:
		iter.ReportError("decode ClusterSpecReplicationSpecsRegionConfigsAnalyticsSpecs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec struct {
}

func (ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) == nil
}

func (ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr)
	var objs []ClusterSpecReplicationSpecsRegionConfigsAutoScaling
	if obj != nil {
		objs = []ClusterSpecReplicationSpecsRegionConfigsAutoScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReplicationSpecsRegionConfigsAutoScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReplicationSpecsRegionConfigsAutoScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}
			}
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecReplicationSpecsRegionConfigsAutoScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = obj
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsAutoScaling)(ptr) = ClusterSpecReplicationSpecsRegionConfigsAutoScaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecReplicationSpecsRegionConfigsAutoScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec struct {
}

func (ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) == nil
}

func (ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr)
	var objs []ClusterSpecReplicationSpecsRegionConfigsElectableSpecs
	if obj != nil {
		objs = []ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReplicationSpecsRegionConfigsElectableSpecsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReplicationSpecsRegionConfigsElectableSpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}
			}
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecReplicationSpecsRegionConfigsElectableSpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = obj
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsElectableSpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsElectableSpecs{}
		}
	default:
		iter.ReportError("decode ClusterSpecReplicationSpecsRegionConfigsElectableSpecs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec struct {
}

func (ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) == nil
}

func (ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr)
	var objs []ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs
	if obj != nil {
		objs = []ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}
			}
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = obj
		} else {
			*(*ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs)(ptr) = ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs{}
		}
	default:
		iter.ReportError("decode ClusterSpecReplicationSpecsRegionConfigsReadOnlySpecs", "unexpected JSON type")
	}
}
